# JSON API with JS

This section mostly requires information which is in JS backend doc

The main difference is that we don't load new pages, we are sending and receiving requests with data

#### Table of Contents

- [JSON API with JS](#json-api-with-js)
      - [Table of Contents](#table-of-contents)
  - [Endpoints](#endpoints)
  - [Responding with JSON](#responding-with-json)
  - [Routes](#routes)
    - [Index](#index)
    - [Create](#create)
    - [Show](#show)
  - [Update](#update)
  - [Delete](#delete)
  - [Helpers](#helpers)
  - [Serving a Static File](#serving-a-static-file)

## Endpoints

Endpoints are basically routes

Example with a todo app (RESTful):

```
Verb     Route                Description
GET      /api/todos           List all todos
POST     /api/todos           Create a new todo
GET      /api/todos/:todoId   Retrieve a todo
PUT      /api/todos/:todoId   Update a todo
DELETE   /api/todos/:todoId   Delete a todo
```

## Responding with JSON

res.send is dynamic, depending on the contents of what we send: if we pass string, it will render html, but if we pass JS object, it will be treated as JSON

```javascript
app.get('/', function(req, res) {
  res.send({message: 'Hi there from JS object'}); // it will convert to a string, and send as JSON
  // if we pass a string, it will be treated as a string
  res.send('{data: 12345}');
});
```

Also there is res.json method which does the same thing because in res.send source code it actually calls res.json (send is sort of parent)

```javascript
app.get('/', function(req, res) {
  res.json({message: 'Hi there from JS object'});
  res.json('{data: 12345}'); // it will treat this string as a JSON
});
```

## Routes

We are assuming that we have this in our index.js file:

```javascript
var todoRoutes = require('./routes/todos');
app.use('/api/todos', todoRoutes);
```

Schema for examples:

```javascript
var mongoose = require('mongoose');

var todoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: 'Name cannot be blank!'
  },
  completed: {
    type: Boolean,
    default: false
  },
  created_date: {
    type: Date,
    default: Date.now
  }
});

var Todo = mongoose.model('Todo', todoSchema);

module.exports = Todo;
```

### Index

```javascript
// index route
router.get('/', function(req, res) {
  db.Todo.find()
  .then(function(todos) {
    res.json(todos);
  })
  .catch(function(err) {
    res.send(err);
  });
});
```

### Create

```javascript
// create route
router.post('/', function(req, res) {
  db.Todo.create(req.body)
  .then(function(newTodo) {
    // standard way to respond is res.send it back since it's importand to know that it worked, and date, the status abd the ID are going to be generated by mongo, so we want those to come back
    // we're also sending a different status code to be more explicit (201 - created)
    res.status(201).json(newTodo);
  })
  .catch(function(err) {
    res.send(err);
  })
});

// if we try to send along some other data (like mood which is not in our schema), it doesn't actually try and insert that because that's not a part of our schema, so mongo doesn't care about that (our only defined key is name in this example)
```

### Show

```javascript
router.get('/:todoId', function(req, res) {
  db.Todo.findById(req.params.todoId)
  .then(function(foundTodo) {
    res.json(foundTodo);
  })
  .catch(function(err) {
    res.send(err);
  })
});
```

## Update

```javascript
router.put('/:todoId', function(req, res) {
  db.Todo.findOneAndUpdate({_id: req.params.todoId}, req.body, {new: true})
  .then(function(todo) {
    res.json(todo); // by default it responds with old data, before it was updated that's why we need {new: true}
  })
  .catch(function(err) {
    res.send(err);
  })
});

module.exports = router;
```

## Delete

```javascript
router.delete('/:todoId', function(req, res) {
  db.Todo.remove({_id: req.params.todoId})
  .then(function() {
    res.json({message: 'We deleted it'});
  })
  .catch(function(err) {
    res.send(err);
  });
});
```

## Helpers

We can refactor routes file by moving all the logic inside our route handlers into a separate helper so that our routes will be really simple
- Look up controllers in MVC framework
- Are helper files the same as Controller files in the MVC framework?
  - Iâ€™d consider the handlers/routesto be more controllers
- MAYBE not true: controller is mainly for processing logic and bringing together database and templates whereas helper is mainly used for shared codes like dates
- Helpers are either in a helpers folder (helpers/todos.js) or named (todos_helper.js)

Exports
- Exports isn't exactly an alias for module.exports. exports.a = function b(){} means that module.exports.a is a function, but setting module.exports = function b(){} can not be done with just exports. If you want to do a "default" export and only export out a single thing, you have to use module.exports

Routes file:

```javascript
var express = require('express'),
    router = express.Router(),
    helpers = require('../helpers/todos');


// index and post routes
router.route('/')
  .get(helpers.getTodos)
  .post(helpers.createTodo);

// show, update, and delete
router.route('/:todoId')
  .get(helpers.getTodo)
  .put(helpers.updateTodo)
  .delete(helpers.deleteTodo);

module.exports = router;
```

Helpers file:

```javascript
var db = require('../models');

// exports object is initialized by node

exports.getTodos = function(req, res) {
  db.Todo.find()
  .then(function(todos) {
    res.json(todos);
  })
  .catch(function(err) {
    res.send(err);
  });
}

exports.createTodo = function(req, res) {
  console.log(req.body);
  db.Todo.create(req.body)
  .then(function(newTodo) {

    res.status(201).json(newTodo);
  })
  .catch(function(err) {
    res.send(err);
  })
}

exports.getTodo = function(req, res) {
  db.Todo.findById(req.params.todoId)
  .then(function(foundTodo) {
    res.json(foundTodo);
  })
  .catch(function(err) {
    res.send(err);
  })
}

exports.updateTodo = function(req, res) {
  db.Todo.findOneAndUpdate({_id: req.params.todoId}, req.body, {new: true})
  .then(function(todo) {
    res.json(todo); // by default it responds with old data, before it was updated that's why we need {new: true}
  })
  .catch(function(err) {
    res.send(err);
  })
}

exports.deleteTodo = function(req, res) {
  db.Todo.remove({_id: req.params.todoId})
  .then(function() {
    res.json({message: 'We deleted it'});
  })
  .catch(function(err) {
    res.send(err);
  });
}

module.exports = exports;
```

## Serving a Static File

We can serve static files with res.sendFile

```javascript
app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/views'));

app.get('/', function(req, res) {
  res.sendFile('index.html');
});
```