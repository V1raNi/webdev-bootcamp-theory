# ES2015 (ES6)

#### Table of Contents

- [ES2015 (ES6)](#es2015-es6)
      - [Table of Contents](#table-of-contents)
  - [What Is ES2015](#what-is-es2015)
  - [ES2015 Features](#es2015-features)
    - [const](#const)
      - [Mutation in JS](#mutation-in-js)
    - [let](#let)
      - [Usage of Let](#usage-of-let)
    - [Template Strings](#template-strings)
    - [Arrow Functions](#arrow-functions)
      - [One-line Arrow Functions](#one-line-arrow-functions)
      - [Peculiarities](#peculiarities)
      - [Arrow Functions and 'arguments'](#arrow-functions-and-arguments)
      - [When Not to Use =>](#when-not-to-use-)
    - [Default Parameters](#default-parameters)
    - [For...of Loops](#forof-loops)
      - [How for...of Works](#how-forof-works)
    - [Rest](#rest)
    - [Spread](#spread)
    - [Object Enhancements](#object-enhancements)
      - [Object Shorthand Notation](#object-shorthand-notation)
      - [Object Methods](#object-methods)
      - [Computed Property Names](#computed-property-names)
    - [Object Destructuring](#object-destructuring)
    - [Array Destructuring](#array-destructuring)
      - [Swapping Values](#swapping-values)
    - [Class Keyword](#class-keyword)
    - [Instance Methods](#instance-methods)
    - [Class Methods](#class-methods)
      - [Where Class Methods Are Useful](#where-class-methods-are-useful)
    - [Inheritance in ES2015](#inheritance-in-es2015)
    - [Super](#super)
    - [Maps](#maps)
      - [Reasons to Use Maps](#reasons-to-use-maps)
      - [When to Use a Map](#when-to-use-a-map)
      - [WeakMap](#weakmap)
    - [Sets](#sets)
      - [WeakSet](#weakset)
      - [Practical Use of WeakSet](#practical-use-of-weakset)
    - [Promises](#promises)
      - [Promise Chaining](#promise-chaining)
      - [Promise.all](#promiseall)
    - [Generators](#generators)
      - [Yield Multiple Values](#yield-multiple-values)
      - [Interating Over a Generator](#interating-over-a-generator)
      - [Async Generator](#async-generator)
    - [Object.assign](#objectassign)
    - [Array.from](#arrayfrom)
    - [find](#find)
    - [findIndex](#findindex)
    - [includes](#includes)
    - [Number.isFinite](#numberisfinite)
  - [Modules](#modules)
    - [Require and Import](#require-and-import)
    - [Import Statement](#import-statement)

## What Is ES2015

ECMA (European Computer Manufacturers Association) was brought to standardize the language (hence the name - ECMAScript)

2009 - ES5; 2015 - ES6 (ES2015)

After 2015, TC39 (a commitee which votes to add new features) decided to release new changes every year since popularity of JS was growing so much

ES2015 additions:
- let, const
- template strings
- arrow functions
- default parameters
- rest and spread operators
- for...of loops
- object shorthand notation
- computed property names
- object destructuring
- array destructuring
- class keyword
- super and extends keywords
- Maps/Sets
- Promises
- Generators
- Object, Number, Array methods
- Less used features:
  - Proxies
    - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
  - Reflect
    - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect
  - Symbol
    - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol

## ES2015 Features

### const

It is an alternative for 'var', it is used for declaring constants - values that can't be redeclared
- Constants which are strictly set and don't change during the whole program are usually written in caps
  - ``const ORANGE = "#ffa600";``

```javascript
var firstInstructor = 'Colt';
firstInstructor = 'Elie';
firstInstructor; // Elie

// You can't change value of a primitive (strings, numbers, booleans, null, undefined, symbol)

const anotherInstructor = 'Tim';
anotherInstructor = 'Elie'; // TypeError
const anotherInstructor = 'New'; // SyntaxError

// We can still change the value of an array or object even if it is assigned using const, i.e. can mutate if it is an object, but not declare again

const numbers = [1, 2, 3, 4];
numbers.push(10);
numbers; // [1, 2, 3, 4, 10]
```

#### Mutation in JS

- In javascript everything apart from the primitive data types is an object under the hood (functions, arrays)
- Next point to note is, Values are immutable and variables are not
- Primitive data types are immutable in JS because they are passed by value, and objects in javascript are passed by reference (not exactly pass by reference but the variable stores the reference to that object), technically this is called call-by-sharing

### let

```javascript
let anotherInstructor = 'Tim';
anotherInstructor = 'Elie'; // no problems here
let anotherInstructor = 'Tim'; // SyntaxError

// we can reassign, but can not redeclare
```

Let keyword creates a brand new scope in JS called block scope (before there were global and function scope)

There are keywords in JS which create blocks for us, some of the include:
- if
- for
- while
- do
- try
- catch

When we use let keyword inside of those blocks we can create our own kind of scope

```javascript
var instructor = 'Elie';

if (instructor === 'Elie') {
  let funFact = 'Plays Cello!';
}

funFact; // ReferenceError (not defined)

// At the top level of programs and functions, let, unlike var, does not create a property on the global object
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
```

When used in functions, let doesn't behave the same way as the var; it has to do with hoisting

The idea behind hoisting is the variables defined using the var keyword will have their variable declarations
lifted to the top of the scope that they are in

```javascript
function helloInstructor() {
  return elie;
  var elie = 'Me!';
}

helloInstructor(); // undefined (since value of the elie is undefined)
// We won't get a EeferenceError
// JS under the hood hoists variable declarations to the top of the function (only the var elie portion)
```

Let keyword hoists as well, but we do not have access to its value, and get a reference error
- Even though it has hoisting, it is in Temporal Dead Zone (TDZ) from start of a block before the declaration is processed
- TDZ is a place where variables are declared, but we cannot access their values

```javascript
function helloSecondInstructor() {
  return colt;
  let colt = 'Him!';
}

helloSecondInstructor(); // ReferenceError
```

#### Usage of Let

Some JS developers replace var with let wherever possible, but this could be condsidered a bit of an extreme (although Google and AirBnb recommend avoid using var)

When we're working inside of a block and do not want variables defined inside of that block to be accessible outside, we use let keyword

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}

// 5 (five times)
// By the time setTimeout runs, the loop has finished, and i is 5

// Before let:
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(i);
    }, 1000);
  })(i)
}

// With let (let is limited in scope to the block in which it is used, and a new variable is created for each iteration of the loop)
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}

// 0
// 1
// 2
// 3
// 4
```

### Template Strings

Sometimes it is known as string interpolation

```javascript
var firstName = 'Elie';
var lastName = 'Schoppik';

console.log('Hello ' + firstName + ' ' + lastName); // error prone and tedious

console.log(`Hello ${firstName} ${lastname}`);

// Multiline strings

// Doesn't work:
// "
// Hello
// "

// Works:
`
Hello
How
Nice
Is
This!
`
```

### Arrow Functions

Arrow functions are easier way to write anonymous functions in ES6, but they have some differences

```javascript
// ES5
var add = function(a,b) {
  return a + b;
}

// ES6
var add = (a, b,) => {
  return a + b;
}
```

#### One-line Arrow Functions

We can put arrow functions on one line, but we must omit the return keyword as well as {}

```javascript
var add = (a, b) => a + b;

// Double elements in an array:
// ES5
[1, 2, 3].map(function(value) {
  return value * 2;
});

// ES6
[1, 2, 3].map(value => value *2);

// Double and filter:
// ES5
function doubleAndFilter(arr) {
  return arr.map(function(value) {
    return value * 2;
  }).filter(function(value) {
    return value % 3 === 0;
  });
}

doubleAndFilter([5, 10, 15, 20]); // [30]

// ES6
var doubleAndFilter = arr => arr.map(val => val * 2).filter(num => num % 3 === 0);
// note that if we only have one parameter, we do not need () around it with =>
```

#### Peculiarities

- Arrow functions are not exactly the same as regular functions
- Arrow functions do not get their own 'this' keyword
- Inside of an arrow function, 'this' has its original meaning from the enclosing context
- The fact that arrow function do not have their own 'this' keyword can be quite helpful, but we need to understand when we might not want that

```javascript
var instructor = {
  firstName: 'Elie',
  sayHi: function() {
    setTimeout(function() {
      console.log('Hello ' + this.firstName);
    }, 1000);
  }
}

instructor.sayHi(); // 'Hello undefined'
// because this of setTimeout - window, not 'instructor', we need to use .bind(this), 1000...

// => as an alternative
var instructor = {
  firstName: 'Elie',
  sayHi: function() {
    setTimeout(() => {
      console.log('Hello ' + this.firstName);
    }, 1000);
  }
}

instructor.sayHi(); // 'Hello Elie'
// It works because 'this' refers to its enclosing context ('instructor' object), and not to the 'window' (=> doesn't have its own context)

// We used both 'function' and '=>' because with two => we would have had the 'window' as the context of 'this'
```

#### Arrow Functions and 'arguments'

Arrow functions do not get their own keyword 'arguments

```javascript
var add = (a, b) => {
  return arguments;
}

add (2, 4); // ReferenceError: arguments is not defined
```

An 'arguments' keyword can be accessed if the arrow function is inside of another function (it will be outer function's arguments)
- If we really need the arguments to an arrow function, use the rest operator

```javascript
function outer() {
  return innerFunction = () => {
    return arguments;
  }
}

outer(1)(2); // only prints out [1]
```

#### When Not to Use =>

Arrow functions should never be used as methods in objects since we will get the incorrect value of 'this'; ES2015 provides a better alternative (see object methods below)

### Default Parameters

```javascript
function add(a, b) {
  return a + b;
}

add(); // Nan because a and b are undefined

// adding default parameters in ES5
function add(a, b) {
  if (a === undefined) {
    a = 2;
  }
  if (b === undefined) {
    b = 2;
  }
  return a + b;
}

// ES6
function add(a = 2, b = 2) {
  retrun a + b;
}

add(); // 4
add(10); // 12
```

### For...of Loops

For...of loop is used to easily iterate over arrays and newer data structures

Syntax (is very similar to for...in which is used too iterate over keys in an object):

```javascript
var arr = [1, 2, 3, 4, 5];

for (let val of arr) {
  console.log(val);
}

// 1
// 2
// 3
// 4
// 5
```

#### How for...of Works

ES2015 gives us a new primitive data type Symbol, and there is a method on symbols called 'iterator' which specifies how a data type is iterated over

Some built-in data types like strings, and special kinds of objects like arrays as well as two new data structures (maps and sets) have that built-in symbol.iterator function
- Objects do not have this, i.e. we can't use for...of with objects
- Also for..of can't access an index

### Rest

Collects remaining arguments of a function and returns them as an array

```javascript
function printRest(a, b, ...c) {
  console.log(a);
  console.log(c);
  console.log(b); // no ... here
}

printRest(1, 2, 3, 4, 5);
// 1
// 2
// [3, 4, 5]

// ES5
function sumArguments() {
  var total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

// A fancier ES5
function sumArguments() {
  var argumentsArray = [].slice.call(arguments); // making an array our of array-like object
  return argumentsArray.reduce(function(acc, next) {
    return acc + next;
  });
}

// ES6
var sumArguments = (...args) => args. reduce((acc, next) => acc + next);
// gather all args as an array so that we don't need to use array-like arguments and then use .reduce with =>
```

### Spread

When ... are used outside of parameters to a function, those three dots are called the spread operator

The idea behind the spread operator is to take an array and spread each value out
- Useful when we have an array, but what we are working with expects comma separated values
- Array.from is useful if we want to run a callback function (the 2nd parameter to Array.from) and the spread operator is useful when concatenating values together or spreading

```javascript
// we have 3 arrays and want to create a new array with all the values of each array

// ES5
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var arr3 = [7, 8, 9];

var combined = arr1.concat(arr2).concat(arr3);

// ES6
var combined = [...arr1, ...arr2, ...arr3]; // ... is not a parameter to a function

// Another common use case is when we have an array of values but are trying to invoke a function which accepts each value individually
// In ES5 it was done using the .apply which as its second parameter accepts an array of arguments which it spreads out

var arr = [3, 2, 4, 1, 5];

Math.max(arr); // NaN

// ES5
Math.max.apply(this, arr); // 5; don't worry about 'this', we don't care what the value of 'this' is, we use it for the second parameter

// ES6
Math.max(...arr); // 5

// Another example:
function sumValues(a, b, c) {
  return a + b + c;
}

var nums = [12, 15, 20];

// ES5
sumValues.apply(this, nums); // 47

// ES6
sumValues(...nums); // 47
```

### Object Enhancements

#### Object Shorthand Notation

```javascript
var firstName = 'Elie';
var lastName = 'Schoppik';

// ES5
var instructor = {
  firstName: firstName,
  lastName: lastName
}

// ES6
var instructor = {
  firstName,
  lastName
}
```

#### Object Methods

A method is a function that is placed on an object

```javascript
// ES5
var instructor = {
  sayHello: function() {
    return 'Hello';
  }
}

// ES6
// We simply omit the colon and the function keyword, and place parentheses after the name of our method
var instructor = {
  sayHello() {
    return 'Hello';
  }
}
```

#### Computed Property Names

```javascript
// ES5
// If we wanted an object to have the key with whatever the value of the firstName variable is, we would have to use bracket notation and let javascript evaluate that
var firstName = 'Elie';
// make an object
var instructor = {};
// assign a value with bracket notation
instructor[firstName] = 'That\'s me!';

instructor.Elie; // That's me!

// ES6
var firstName = 'Elie';
// we can assign a value with bracket notation while defining our object; JS computes the name of the property
var instructor = {
  [firstName]: 'That\'s me!'
};

instructor.Elie; // That's me!
```

### Object Destructuring

Destructuring is extracting values from data stored in objects and arrays (into distinct variables)

```javascript
// ES5
var instructor = {
  firstName: 'Elie',
  lastName: 'Schoppik'
}

var firstName = instructor.firstName;
var lastName = instructor.lastName;

firstName; // 'Elie'
lastName; // 'Schoppik'

// destructuring:
var instructor = {
  firstName: 'Elie',
  lastName: 'Schoppik'
}

var {firstName, lastName} = instructor;
// left side is wrapped in an object
// What we're doing here is creating two variables: firstName and lastName, which are destructured (or unpacked) from the instructor object
// We have to name our variables the same exact names as the keys in the object we are destructuring

firstName; // 'Elie'
lastName; // 'Schoppik'

// If we want to make different variable names:
var {firstName: first, lastName: last} = instructor;

first; // 'Elie'
last; // 'Schoppik'
```

More complex example:

```javascript
// ES5 Default values with an object
function createInstructor(options) {
  var options = options || {};
  var name = options.name || {first: 'Matt', last: 'Lane'};
  var isHilarious = options.isHilarious || false;
  return [name.first, name.last, isHilarious];
}

createInstructor(); // ['Matt', 'Lane', false]
createInstructor({isHilarious: true}); // ['Matt', 'Lane', true]
createInstructor({name: {first: 'Tim', last: 'Garcia'}}); // ['Tim', 'Garcia', false]

// ES6
// passing a destructured object as a parameter to a function, and specifying the keys of name and isHilarious with default values
// at the end of the parameter we're assigning the whole thing to be an empty object so that ES2015 knows that our default parameter is a destructured object
// if nothing is passed in, we default to the destructured object as the parameter
function createInstructor({name = {first: 'Matt', last: 'Lane'}, isHilarious = false} = {}) {
  return [name.first, name.last, isHilarious];
}
```

Another case where we can destructure objects and pass in fields or keys in an object as parameters:

```javascript
// ES5
// If we want to display properties from an object, we can pass that object in as a parameter and return some values
function displayInfo(obj) {
  return [obj.name, obj.favColor];
}

var instructor = {
  name: 'Elie',
  favColor: 'Purple'
};

displayInfo(instructor); // ['Elie', 'Purple']

// ES6
// If we know the names of the keys that we will be using from a single object, we can destructure those keys as parameters

// here we have a function displayInfo which accepts an object with the keys of name and favColor
// if we create an object with the keys of name and favColor, we can invoke this function and destructure the instructor object
function displayInfo({name, favColor}) {
  return [name, favColor];
}

var instructor = {
  name: 'Elie',
  favColor: 'Purple'
};

displayInfo(instructor); // ['Elie', 'Purple']
```

### Array Destructuring

```javascript
// ES5
var arr = [1, 2, 3];
var a = arr[0];
var b = arr[1];
var c = arr[2];

a; // 1
b; // 2
c; // 3

// ES6

var arr = [1, 2, 3];

var [a, b, c] = arr;

a; // 1
b; // 2
c; // 3

// ES5
function returnNumbers(a, b) {
  return [a, b];
}

// invoking the function twice to get and assign the value
var first = returnNumbers(5, 10)[0];
var second = returnNumbers(5, 10)[1];

first; // 5
second; // 10

// ES6
function returnNumbers(a, b) {
  return [a, b];
}

[first, second] = returnNumbers(5, 10);

first; // 5
second; // 10
```

#### Swapping Values

One of the most helpful things that we can do with array destructuring is swap values in an array (this is quite common if we don't want to make a new array, but just want to switch the places of certain values, which is common especially with sorting algorithms)

```javascript
// Traditionally this was done with a function that created a temporary variable to store the first value to be swapped
// We then would reassign the first value to be the second value and the second value to be the temporary value

// ES5
function swap(a, b) {
  var temp = a;
  a = b;
  b = temp;
  return [a, b];
}

swap(10, 5); // [5, 10]

// In ES2015 we're assigning the value of a destructured array to be another array with the value switched
// ES6
function swap(a, b) {
  return [a, b] = [b, a];
}

swap(10, 5); // [5, 10]
```

### Class Keyword

- A new reserved keyword
- The class keyword creates a constant - it cannot be redeclared
- The class keyword is an abstraction of constructor functions and prototypes
  - Remember that JS doesn't have built-in support for OOP
- Class keyword does not hoist
  - They should be placed on top part of the code
- We still use 'new' keyword to create objects

```javascript
// ES5
function Student(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

var elie = new Student('Elie', 'Schoppik');
// create a constructor function - use 'new' to create objects

// ES6
class Student {
  // constructor method
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
}

var elie = new Student('Elie', 'Schoppik'); // instanciation, creating an instance
// use 'class' instead of creating a function - use a special method constructor which is run when 'new' is used - use the 'new'

// There is no notion of constructor functions or prototypes so there's still some resistance in the javascript community around this addition since it abstracts so much, however it is a standard practice nowadays
```

### Instance Methods

We add methods which can be used by every single object created from the class by constructor function - instance methods

```javascript
// ES5
// Methods and properties were traditionally placed on the prototype object
function Student(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Student.prototype.sayHello = function() {
  return 'Hello ' + this.firstName + ' ' + this.lastName;
}

// ES6
// it is also far more efficient to create instance methods and to place those methods inside of the constructor
// if we place methods inside of the constructor, they are redefined each time we create an object from that class

// methods are placed inside of 'class' keyword; no 'function' keyword - similar to object shorthand notation
// under the hood it is placing methods on the prototype object
class Student {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  sayHello() {
    return `Hello ${this.firstName} ${this.lastName}`;
  }
}
```

### Class Methods

Class methods are methods placed directly on the constructor function (like Array.isArray which is directly on Array.constructor)

```javascript
// ES5
function Student(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Student.prototype.sayHello = function() {
  return 'Hello ' + this.firstName + ' ' + this.lastName;
}

Student.isStudent = function(obj) {
  return obj.constructor === Student;
}

// ES6
// Methods and properties added directly onto a class are called statics and make use of the 'static' keyword
class Student {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  sayHello() {
    return `Hello ${this.firstName} ${this.lastName}`;
  }
  static isStudent(obj) {
    return obj.constructor === Student;
  }
}

// we can invoke this method directly to see if the object was created from the Student class
var s = new Student('E', 'S');
Student.isStudent(s); // true
Student.isStudent([]); // false
```

#### Where Class Methods Are Useful

Sometimes we don't want every object created from a class to have its own method, specifically when we want to use the method without creating objects from that class

```javascript
typeof []; // object
Array.isArray([]); // true
// this method is a static method on the array constructor function
Object.create;
Object.freeze; // prevents an object from being modified
```

### Inheritance in ES2015

Passing along methods and properties from one class to another

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Person.prototype.sayHello = function() {
  return 'Hello ' + this.firstName + ' ' + this.lastName;
}

function Student(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

// we want sayHello() of Person to be accessible by objects created by Student
// the most common way is to set the prototype property of one function to be a new object with a __proto__ property of another constructor function's prototype, i.e.
// Set the prototype property of a constructor to be an object created from another prototype property and reset the constructor property on the constructor function

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// ES6
// This is done with 'extends' keyword
// If one class extends another, it will have all the methods that that class, which it extends from, has
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  sayHello() {
    return `Hello ${this.firstName} ${this.lastName}`;
  }
}

class Student extends Person {

}

Student.prototype.sayHello; // exists
Student.prototype.constructor === Student; // true
```

### Super

The idea behind 'super' is to find a method by the same name in the parent class or the class which has passed down methods and properties to a child class

```javascript
// ES5
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Person.prototype.sayHello = function() {
  return 'Hello ' + this.firstName + ' ' + this.lastName;
}

function Student(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

// notice the duplication in the Student
// is there any way to 'borrow' the code from the Person function and use it in the Student?
// we can't just invoke the Person because the value of 'this' is important
// we can use .call or .apply
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Person.prototype.sayHello = function() {
  return 'Hello ' + this.firstName + ' ' + this.lastName;
}

// we invoke the Person and specify the value of 'this' to be the object created from the student function using the 'new'
// we could use call as well, but 2nd parameter of .apply is an array, we can use arguments array-like object to capture all of the arguments passed to the function (easier with many params)
function Student() {
  Person.apply(this, arguments);
}

// ES6
// we use 'super'
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  sayHello() {
    return `Hello ${this.firstName} ${this.lastName}`;
  }
}

// Person - parent, Student - child
// in our constructor method we will use super which will invoke a method by the same name in the Person class
// super can only be used if a method by the same name is implemented in the parent class
class Student extends Person {
  constructor(firstName, lastName) {
    super(firstName, lastName);
  }
  // we can also do:
  constructor() {
    super(...arguments);
  }
}
```

### Maps

Also called 'hash maps' or 'hash' in other languages; in JS until ES6 objects were replacement for maps

Maps are similar to objects, except the keys can be any data type
- In JS, data type for keys in objects is always a string
- Both let us set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key
- Maps are created with 'new'

```javascript
var firstMap = new Map;

firstMap.set(1, 'Elie');
firstMap.set(false, 'a boolean');
firstMap.set('nice', 'a string');

firstMap.delete('nice'); // true
firstMap.size; // 2

// keys are 1, false, 'nice'; keys can even be arrays and objects
var arrayKey = [];
firstMap.set(arrayKey, [1, 2, 3, 4, 5]);
var objectKey = {};
firstMap.set(objectKey, {a: 1});

// extracting values
firstMap.get(1); // 'Elie'
firstMap.get(false); // 'a boolean'
firstMap.get(arrayKey); // [1, 2, 3, 4, 5]
firstMap.get(objectKey); // {a: 1}

// iteration
firstMap.forEach(value => console.log(value));

// maps implement a Symbol.iterator which means we can use a for...of loop
firstMap.value(); // MapIterator of values
firstMap.keys(); // MapIterator of keys
```

#### Reasons to Use Maps

- Finding the size is easy - no more loops or Object.keys()
- The keys can be any data type
- Maps do not have that issue when we can accidentally overwrite keys on the Object.prototype in an object we make (they do not have their own prototype object)
- Iterating over keys and values in a map is quite easy

#### When to Use a Map

- If we need to look up keys dynamically (they are not hard coded strings)
  - We can think of it like using bracket notation with objects
- If we need keys that are not strings
- If we are frequently adding and removing key/value pairs
- If we're operating on multiple keys at a time

#### WeakMap

WeakMap is similar to a map, except all the keys must be objects, and not primitives

This makes a WeakMap more performant than a map, but we cannot iterate over a WeakMap since values can be cleared from memory if there is no reference to them

### Sets

- A set is a data structure in which all of the values are unique
- We can place any value we'd like in a set
- Sets exist in many languages
- Sets are created with 'new'
- Sets are used when we want to ignore duplicate values, we don't need to identify values with keys, or care about the ordering of values

```javascript
var s = new Set;

s.add(10); // {10}
s.add(20); // {20, 10}
s.add(10); // {20, 10}
s.size; // 2

// can also be created from an array
var s2 = new Set([3, 1, 4, 1, 2, 1, 5]); // {3, 1, 4, 2, 5}

// to see if a set contains a value
s.has(10); // true

// to delete
s.delete(20); // true
s.size; // 1

// sets implement a Symbol.iterator - we can use a for...of loop
s2[Symbol.iterator]; // function() {}...
```

#### WeakSet

Similar to maps, there is also a WeakSet data structure, which is more performant than a regular set, but all of the values have to be objects just like WeakMaps

Values in a WeakSet can be cleared from memory if there is no reference to them, and cannot be iterated over

#### Practical Use of WeakSet

All you can get is one bit of information: Is the object (or generically, value) contained in the set?

This can be useful in situations where you want to "tag" objects without actually mutating them (setting a property on them)

Lots of algorithms contain some sort of "if x was already seen" condition (a JSON.stringify cycle detection might be a good example), and when you work with user-provided values the use of a Set/WeakSet would be advisable

The advantage of a WeakSet here is that its contents can be garbage-collected while your algorithm is still running, so it helps to reduce memory consumption (or even prevents leaks) when you are dealing with lots of data that is lazily (possibly even asynchronously) produced

### Promises

Promise is a one time guaranteed return of some future value; when the value is figured out - the promise is resolved (fulfilled) or rejected
- See more at 'asynchronous JS -> Promises'

ES 2015 provides a way for creating native promises

- Created using the 'new' keyword
- Every promise constructor accepts a callback function which contains two parameters: resolve and reject (most common names)
- Resolve and reject are both functions to be run if the promise is resolved or rejected

```javascript
function displayAtRandomTime() {
  return new Promise(function(res, rej) {
    setTimeout(function() {
      if (Math.random() > .5) {
        resolve ('Yes');
      } else {
        reject('No!');
      }
    }, 1000);
  });
}
```

The returned value from a promise will always contain a .then and .catch methods which are functions to be executed when the promise is resolved or rejected
- .then accepts a callback function with the value passed to the resolve function
- .catch accepts a callback function with the value passed to the reject function

#### Promise Chaining

Since a promise always returns something that has a .then (thenable) - we can chain promises together and return values from one promise to another

```javascript
var years = [];
$.getJSON('https://omdbapi.com?t=titanic&apikey=thewdb');
// AJAX jquery methods return a promise, so we can call .then directly on the result of the AJAX method returned to us
.then(function(movie) {
  years.push(movie.Year);
  return $.getJSON('https://omdbapi.com?t=shrek&apikey=thewdb');
})
// we'll then return another AJAX call as a promise and when it's done being resolved we'll prin out the movie years
.then(function(movie) {
  years.puch(movie.Year);
  console.log(years);
})

console.log('All done'); // it will print before years since this entire operation is async

// All done
// ['1997, '2001']
```

#### Promise.all

It is a method on a promise constructor

- Accepts an array of promises and resolves all of them or rejects once a single one of the promises has been first rejected (fail fast behavior)
- If all of the passed-in promises fullfill, Promise.all is resolved with an array of the values from the passed-in promises, in the same order as the promises passed in to Promise.all
- Promise.all doesn't guarantee that these promises will resolve sequentially, that it will return an array of resolved promises in the same order that you pass them in to the function
  - Something like this happens with $.when in jQuery or Q
- The promises don't resolve sequentially, but Promise.all waits for them to resolve

```javascript
function getMovie('title'){
  return $.getJSON(`https://omdbapi.com?t=${title}&apikey=thewdb`);
}

// value of these variables is a pending promise, it has not been rejected or resolved, there is simply a promise for some future value
var titanicPromise = getMovie('titanic');
var shrekPromise = getMovie('shrek');
var braveheartPromise = getMovie('braveheart');

// instead of chaining all of these promises together with .then and another .then and another .then, we can simply place them all inside of a Promise.all invocation
Promise.all([titanicPromise, shrekPromise, braveheartPromise]).then(function(movies) {
  return movies.forEach(function(value) {
    console.log(value.Year);
  });
});

// 1997
// 2001
// 1995
```

### Generators

- A special kind of function which we can pause execution and resume at any time
- Generators are the foundation for some complex libraries that help manage async code
  - But there is a newer way to manage it - ES2017 async functions
- Created using a *
- When invoked, a generator object is returned to us, and it has a method 'next' which returns another object with the keys of 'value' and 'done'
- Value is what is returned from the paused function using the 'yield' keyword
- Done is a boolean which returns true when the function is completed

```javascript
function* pauseAndReturnValues(num){
  for (let i = 0; i < num; i++) {
    yield i;
  }
}

var gen = pauseAndReturnValues(5);
gen.next(); // {value: 0, done: false}
gen.next(); // {value: 1, done: false}
gen.next(); // {value: 2, done: false}
gen.next(); // {value: 3, done: false}
gen.next(); // {value: 4, done: false}
gen.next(); // {value: undefined, done: true}
```

#### Yield Multiple Values

We can place multiple yield keywords inside of a generator function to pause multiple times

```javascript
function* printValues() {
  yield 'First';
  yield 'Second';
  yield 'Third';
}

var g = printValues();
g.next().value; // 'First'
g.next().value; // 'Second'
g.next().value; // 'Third'
```

#### Interating Over a Generator

Since generators implement a Symbol.iterator property, we can use a for...of loop

```javascript
function* pauseAndReturnValues(num){
  for (let i = 0; i < num; i++) {
    yield i;
  }
}

for (val of pauseAndReturnValues(3)) {
  console.log(val);
}

// 0
// 1
// 2
```

#### Async Generator

We can use generators to pause async code; since we can pause a function, we can pause the result of some async operation and then continue

```javascript
// we're pausing a promise and using .then to resolve it
// we can have multiple yield statements for different promises and resolve them whenever we'd like and then continue resuming our function
function* getMovieData(movieName) {
  console.log('starting');
  yield $.getJSON(`https://omdbapi.com?t=${movieName}&apikey=thewdb`);
  console.log('ending');
}

var movieGetter = getMovieData('titanic');
movieGetter.next().value.then(val => console.log(val));
```

### Object.assign

A common problem in JS is dealing with making copies of objects because we can't simply assign one to another (it creates reference, not creates a new object)

```javascript
var o = {name: 'Elie'};
var o2 = o;
o2.name = 'Tim';
o.name; // 'Tim'
```

Object.assign is a way to create objects without the same reference
- Accepts a series of objects, and will return a new object with the keys and values for all the objects passed to it
- If we don't start with an empty object (as the first parameter), object outside will still keep a reference to another object included in it

```javascript
var o = {name: 'Elie'};
var o2 = Object.assign({}, o);

o2.name = 'Tim';
o.name; // 'Elie'
```

It does not create a deep clone, so if there are objects inside of the object that we're copying, those references will stil be there
- If we need a deep clone, we can write our own function or use different data structures, or popular libraries like lodash

```javascript
var o = {instructors: ['Elie', 'Tim']};
var o2 = Object.assign({}, o);

o2.instructors.push('Colt');
o.instructors; // ['Elie', 'Tim', 'Colt']
```

### Array.from

Array.from allows us to convert other data types  (e.g. array-like object) into an array if possible
- It works with strings, maps, sets, array-like objects

Array-like objects are quite common
- document.getElementsByTagName
- using jQuery to select elements from the DOM
- arguments keyword

```javascript
// ES5

var divs = documents.getElementsByTagName('div'); // returns an array-like obj

divs.reduce // undefined, since it's not an array

var converted = [].slice.call(divs); // convert the array-like object into an array

converted.reduce // function reduce() {...}

// ES6
var divs = documents.getElementsByTagName('div');
var converted = Array.from(divs);
// notice that .from method is invoked directly on the array function - this is another example of a static method

var firstSet = new Set([1, 2, 3, 4, 3, 2, 1]); // {1, 2, 3, 4}
var arrayFromSet = Array.from(firstSet); // [1, 2, 3, 4]
```

### find

- Invoked on arrays
- Accepts a callback with value, indes, and array (just like forEach, map, filter, etc.)
- Inside of the callback function we can return a condition
  - If that condition returns true, the first item found is returned
- Returns the value found of undefined if not found
- Very useful way of searching through an array and return a value without having to use a 'for' loop

```javascript
var instructors = [{name: 'Elie'}, {name: 'Matt'}, {name: 'Tim'}, {name: 'Colt'}];

instructors.find(function(val) {
  return val.name === 'Tim';
}); // {name: 'Tim'}
```

### findIndex

Similar to find, but returns an index or -1 if the value is not found

```javascript
var instructors = [{name: 'Elie'}, {name: 'Matt'}, {name: 'Tim'}, {name: 'Colt'}];

instructors.findIndex(function(val) {
  return val.name === 'Tim';
}); // 2
```

### includes

Returns a boolean of a value is in a string - easier than using indexOf

```javascript
// indexOf will return -1 if the value is not found, so we write some conditional logic
// ES5
'awesome'.indexOf('some') > -1 // true

// instead we can use includes which returns true or false
// ES6
'awesome'.includes('some'); // true
```

### Number.isFinite

A static method on a Number constructor

Checking to see if a number is not a number can be tricky since type of NaN is actually number

Now we can use Number.isFinite
- Anything that is not a number will return false, and NaN is not finite

```javascript
// ES5
function seeIfNumber(val) {
  if (typeof val === 'number' && !isNan(val)) {
    return 'It is a number';
  }
}

// ES6
function seeIfNumber(val) {
  if (Number.isFinite(val)) {
    return 'It is a number';
  }
}
```

## Modules

https://learn.javascript.ru/modules

https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/


### Require and Import

http://voidcanvas.com/import-vs-require/
https://www.educba.com/require-vs-import/

For importing express: ``import * as  express from 'express';``

Require:

- You can have dynamic loading where the loaded module name isn't predefined /static, or where you conditionally load a module only if it's "truly required" (depending on certain code flow).
- Loading is synchronous. That means if you have multiple requires, they are loaded and processed one by one.

ES6 Imports:

- You can use named imports to selectively load only the pieces you need. That can save memory.
- Import can be asynchronous (and in current ES6 Module Loader, it in fact is) and can perform a little better.

### Import Statement

```javascript
// in app.js:

import React, { Component } from 'react';
// React is without {} because it is a default export from the file, and Component is export from that file but not by default
// if it's a node package, we write it as it is

export default App;

// in index.js:

import App from './App'; 
// in order for it to work, app.js and index.js should be in the same dir (.js can be omitted)
// the name here when we export something by default is not important, it could be 'import Pizza from...'

// if we change export in app.js to
export {App};

// in index.js we should
import { App } from './App';
// the name here is important, but can be changed using
import { App as Pizza } from './App';

// you can also import other files
import './Pet.css';
```